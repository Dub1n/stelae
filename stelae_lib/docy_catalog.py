"""Docy catalog helpers (load/save/mutate/render)."""

from __future__ import annotations

import json
from pathlib import Path
from typing import Any, Dict, Iterable, List, Tuple

from .docy_utils import DocySource, slugify, write_atomic


class DocyCatalog:
    def __init__(self, path: Path, sources: List[DocySource]) -> None:
        self.path = path
        self._sources = sources

    @classmethod
    def load(cls, path: Path) -> "DocyCatalog":
        if not path.exists():
            return cls(path, [])
        try:
            data = json.loads(path.read_text(encoding="utf-8"))
        except json.JSONDecodeError as exc:
            raise ValueError(f"Docy catalog {path} is invalid JSON: {exc}") from exc
        items = data.get("sources", [])
        sources = [DocySource.from_dict(raw) for raw in items]
        return cls(path, sources)

    def list_sources(self) -> List[Dict[str, Any]]:
        return [source.to_dict() for source in sorted(self._sources, key=lambda s: s.id)]

    def save(self) -> None:
        payload = {"sources": self.list_sources()}
        write_atomic(self.path, json.dumps(payload, indent=2, ensure_ascii=False) + "\n")

    def _ensure_unique_id(self, base: str) -> str:
        candidate = base
        index = 1
        ids = {source.id for source in self._sources}
        while candidate in ids:
            index += 1
            candidate = f"{base}-{index}"
        return candidate

    def add_source(
        self,
        *,
        url: str,
        title: str | None = None,
        source_id: str | None = None,
        tags: Iterable[str] | None = None,
        notes: str | None = None,
        enabled: bool = True,
        refresh_hours: int | None = None,
        allow_update: bool = False,
    ) -> Tuple[DocySource, str]:
        clean_url = url.strip()
        if not clean_url:
            raise ValueError("url is required")
        identifier = (source_id or title or clean_url).strip()
        if not identifier:
            identifier = clean_url
        slug = slugify(identifier)
        refresh_value = int(refresh_hours) if refresh_hours is not None else None
        existing_by_id = {source.id: source for source in self._sources}
        existing_by_url = {source.url: source for source in self._sources}

        if slug in existing_by_id:
            if not allow_update:
                raise ValueError(f"Source id '{slug}' already exists; pass allow_update to overwrite")
            target = existing_by_id[slug]
            target.url = clean_url
            target.title = title or target.title
            target.tags = [str(tag).strip() for tag in (tags or target.tags) if str(tag).strip()]
            target.notes = notes if notes is not None else target.notes
            target.enabled = enabled
            if refresh_value is not None:
                target.refresh_hours = refresh_value
            return target, "updated"

        if clean_url in existing_by_url:
            target = existing_by_url[clean_url]
            if not allow_update:
                raise ValueError(
                    f"Source for URL '{clean_url}' already exists as id '{target.id}'; pass allow_update to overwrite"
                )
            target.title = title or target.title
            target.tags = [str(tag).strip() for tag in (tags or target.tags) if str(tag).strip()]
            target.notes = notes if notes is not None else target.notes
            target.enabled = enabled
            if refresh_value is not None:
                target.refresh_hours = refresh_value
            return target, "updated"

        slug = self._ensure_unique_id(slug)
        new_source = DocySource(
            id=slug,
            url=clean_url,
            title=title.strip() if title else None,
            tags=[str(tag).strip() for tag in (tags or []) if str(tag).strip()],
            notes=notes.strip() if notes else None,
            enabled=enabled,
            refresh_hours=refresh_value,
        )
        self._sources.append(new_source)
        return new_source, "created"

    def remove_source(self, *, source_id: str | None = None, url: str | None = None) -> DocySource:
        target: DocySource | None = None
        if source_id:
            slug = source_id.strip()
            target = next((src for src in self._sources if src.id == slug), None)
        if target is None and url:
            clean_url = url.strip()
            target = next((src for src in self._sources if src.url == clean_url), None)
        if target is None:
            raise ValueError("No matching source found for provided id/url")
        self._sources.remove(target)
        return target

    def render_urls(self, output_path: Path) -> List[str]:
        lines = [
            "# Generated by scripts/render_docy_sources.py",
            "# Edit config/docy_sources.json instead of this file",
        ]
        active_sources = [src for src in self._sources if src.enabled]
        for source in sorted(active_sources, key=lambda s: s.id):
            lines.append("")
            lines.append(f"# id: {source.id}")
            if source.title:
                lines.append(f"# title: {source.title}")
            if source.tags:
                lines.append(f"# tags: {', '.join(source.tags)}")
            if source.notes:
                lines.append(f"# notes: {source.notes}")
            lines.append(source.url)
        content = "\n".join(lines).rstrip() + "\n"
        write_atomic(output_path, content)
        return lines
