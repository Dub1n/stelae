# Stelae MCP Tool Invocation Log - 2025-11-14

- Session opened against `http://127.0.0.1:9090/mcp` and every tool from the current `tools/list` payload was invoked via `tools/call`, per the AGENTS.md directive to rely on real MCP responses.
- Commands were issued with a small Python harness that reuses `dev/debug/chatgpt_connector_probe.py`; the raw "curl-style" transcript (full JSON for each HTTP request/response) lives at `dev/logs/tool_invocations/20251114T104345Z-tool-calls.json`.
- Each tool was also invoked through the MCP bridge (`mcp__stelae__*` adapters) so we can capture what Codex sees when it calls the tool directly; those outputs are summarized below and can be reproduced by reusing the same adapters.
- Follow-up captures for the `manage_docy_sources` serialization fix live at `dev/logs/tool_invocations/20251114T225700Z-manage_docy_sources.json`.
- The table now compares both perspectives so we can spot gaps (double-encoding, schema validation errors, discovery drift, etc.) without rerunning the probes.
- 2025-11-15 refresh: reran `scripts/run_restart_stelae.sh --keep-pm2 --no-bridge --no-cloudflared`, re-collected `manage_stelae` + `memory_suite`, and rechecked `workspace_shell_control` after pointing its `--workdir` at `${STELAE_DIR}`.

### Logging method

- Each table row now records the literal JSON (trimmed) returned by the proxy via `curl` and by the MCP adapter (`mcp__stelae__*`). This makes it obvious when schema translations drift away from expectations.
- JSON snippets are abbreviated for readability: `…` indicates removed keys/entries, and `<truncated>` marks shortened string bodies. Keep identifiers (`id`, `structuredContent`, etc.) intact so schema diffs remain meaningful.
- Capture the `curl` column with the exact JSON-RPC payload sent to `/mcp`, piped through `jq` (trim large text manually if needed). Capture the MCP column by calling the adapter directly and copying the resulting JSON (again trimming only the `text` payloads).
- When logging future runs, prefer deterministic sample arguments so the snippets remain comparable clone-to-clone.

| Tool | Operation / arguments | curl JSON excerpt | Direct MCP JSON excerpt | Expected response | Required fixes | Notes |
| --- | --- | --- | --- | --- | --- | --- |
| `doc_fetch_suite` | Ops: fetch_document_links, fetch_documentation_page, list_documentation_sources_tool.<br>Sample: `{"operation":"list_documentation_sources_tool"}` | <pre>{"id":"docfetch-list","result":{"content":[{"text":"Available documentation sources:[ARCH…, README…, https://www.example.com]","type":"text"}],"structuredContent":{"result":"Available documentation sources:[ARCH…, README…, https://www.example.com]"}}}</pre> | <pre>{"result":"Available documentation sources:[ARCH…, README…, https://www.example.com]"}</pre> | <pre>{"result":"Available documentation sources:[ARCH…, README…, https://www.example.com]"}</pre> |  | Confirms Docy + fetch wrapper now read directly from `${STELAE_CONFIG_HOME}`. |
| `doc_fetch_suite` | Ops: fetch_document_links, fetch_documentation_page, list_documentation_sources_tool.<br>Sample: `{"operation":"fetch_documentation_page","url":"https://www.example.com"}` | <pre>{"id":"docfetch-example","result":{"content":[{"text":"# Example Domain\n…","type":"text"}],"structuredContent":{"result":"# Example Domain\n…"}}}</pre> | <pre>{"result":"# Example Domain\nThis domain is for use in documentation examples…<truncated>"}</pre> | <pre>{"result":"# Example Domain\nThis domain is for use in documentation examples…<truncated>"}</pre> |  | Placeholder doubles as a regression test for the fetch pipeline. |
| `grep` | Ops: native `grep` arguments (pattern, paths, flags).<br>Sample: `{"pattern":"Stelae","paths":["README.md"],"recursive":false,"max_count":5}` | <pre>{"id":"grep1","result":{"content":[{"text":"{\"content\":[{\"type\":\"text\",\"text\":\"No matches found\"}],\"isError\":false}","type":"text"}],"structuredContent":{"result":{"content":[{"text":"No matches found","type":"text"}],"isError":false}}}}</pre> | <pre>{"result":{"content":[{"text":"No matches found","type":"text"}],"isError":false}}</pre> | <pre>{"result":{"content":[{"text":"No matches found","type":"text"}],"isError":false}}</pre> |  | Wrapper still emits JSON-in-text for the `content` block, but structuredContent is correct. |
| `manage_docy_sources` | Ops: list_sources, add_source, remove_source, sync_catalog, import_from_manifest.<br>Sample: `{"operation":"list_sources"}` | <pre>{"id":"docylist","result":{"content":[{"text":"{'sources':[{'id':'stelae-architecture-guide',…},{'id':'stelae-tool-invocation-log','url':'https://www.example.com'}],'catalogPath':'/home/gabri/.config/stelae/docy_sources.local.json','urlFile':'/home/gabri/.config/stelae/.state/docy/.docy.urls'}","type":"text"}],"structuredContent":{"result":{"catalogPath":"/home/gabri/.config/stelae/docy_sources.local.json","sources":[…],"urlFile":"/home/gabri/.config/stelae/.state/docy/.docy.urls"}}}}</pre> | <pre>{"result":{"catalogPath":"/home/gabri/.config/stelae/docy_sources.local.json","sources":[{"id":"stelae-architecture-guide",…},{"id":"stelae-mcp-stack-readme",…},{"id":"stelae-tool-invocation-log","url":"https://www.example.com"}],"urlFile":"/home/gabri/.config/stelae/.state/docy/.docy.urls"}}</pre> | <pre>{"result":{"catalogPath":"${STELAE_CONFIG_HOME}/docy_sources.local.json","sources":[{"id":"stelae-architecture-guide",…},{"id":"stelae-mcp-stack-readme",…},{"id":"stelae-tool-invocation-log","url":"https://www.example.com"}],"urlFile":"${STELAE_STATE_HOME}/docy/.docy.urls"}}</pre> |  | Shows the placeholder diagnostics entry without touching tracked templates. |
| `manage_stelae` | Ops: list_discovered_servers, install_server, remove_server, refresh_discovery, run_reconciler, discover_servers.<br>Sample: `{"operation":"list_discovered_servers"}` | <pre>{"id":"manage-stelae","result":{"content":[{"text":"{\n  \"status\": \"ok\",\n  \"details\": {\n    \"servers\": [\n      {\"name\":\"pinecone-io-assistant-mcp\",…},\n      {\"name\":\"sirmews-mcp-pinecone\",…}\n    ],\n    \"path\": \"/home/gabri/.config/stelae/.state/discovered_servers.json\"\n  },\n  \"files_updated\": [],\n  \"commands_run\": [],\n  \"warnings\": [],\n  \"errors\": []\n}","type":"text"}],"structuredContent":{"result":{"status":"ok","details":{"servers":[{\"name\":\"pinecone-io-assistant-mcp\",…},{\"name\":\"sirmews-mcp-pinecone\",…}],\"path\":\"/home/gabri/.config/stelae/.state/discovered_servers.json\"},\"files_updated\":[],\"commands_run\":[],\"warnings\":[],\"errors\":[]}}}}</pre> | <pre>{"result":{"status":"ok","details":{"servers\":[{\"name\":\"apecloud-aperag\",…},{\"name\":\"public_mcp_catalog\",…},{\"name\":\"qdrant\",…},…],\"path\":\"${STELAE_STATE_HOME}/discovered_servers.json\"},\"files_updated\":[],\"commands_run\":[],\"warnings\":[],\"errors\":[]}}</pre> | <pre>{"result":{"status":"ok","details\":{\"path\":\"${STELAE_STATE_HOME}/discovered_servers.json\",\"servers\":[{\"name\":\"apecloud-aperag\",…},{\"name\":\"public_mcp_catalog\",…},{\"name\":\"qdrant\",…},…]},\"files_updated\":[],\"commands_run\":[],\"warnings\":[],\"errors\":[]}}</pre> | HTTP + CLI now resolve the `.state` path (env expansion fixed), but the adapter still loads without `STELAE_CONFIG_HOME` so it falls back to the template cache; need Codex launcher to source `.env` before invoking the MCP adapter. | Adapter will stay stale until the launcher exports `STELAE_CONFIG_HOME` / `STELAE_STATE_HOME`; once it does, both surfaces match. |
| `memory_suite` | Ops: build_context, canvas, create_memory_project, delete_note, delete_project, edit_note, get_current_project, list_memory_projects, move_note, read_content, read_note, recent_activity, search_notes, set_default_project, switch_project, sync_status, view_note, write_note.<br>Sample: `{"operation":"list_memory_projects"}` | <pre>{"id":"mem-list","result":{"content":[{"text":"Available projects:\n• main\n• stelae (current, default)\n\n\n&lt;!-- Project: stelae --&gt;","type":"text"}],"structuredContent":{"result":"Available projects:\n• main\n• stelae (current, default)\n\n\n&lt;!-- Project: stelae --&gt;"}}}</pre> | <pre>{"result":"Available projects:\n• main\n• stelae (current, default)\n\n\n&lt;!-- Project: stelae --&gt;"}</pre> | <pre>{"result":"Available projects:\n• main\n• stelae (current, default)\n\n\n&lt;!-- Project: stelae --&gt;"}</pre> |  | Confirms Basic Memory is running again after the restart. |
| `scrapling_fetch_suite` | Ops: s_fetch_page, s_fetch_pattern.<br>Sample: `{"operation":"s_fetch_page","url":"https://example.com","mode":"basic","format":"markdown","max_length":2000}` | <pre>{"id":"scrapling","result":{"content":[{"text":"METADATA:{\"total_length\":171,…}\n\n# Example Domain\n…","type":"text"}],"structuredContent":{"result":"METADATA:{\"total_length\":171,…}\n\n# Example Domain\n…"}}}</pre> | <pre>{"result":"METADATA:{\"total_length\":171,\"retrieved_length\":171,…}\n\n# Example Domain\n…<truncated>"}</pre> | <pre>{"result":"METADATA:{\"total_length\":<n>,\"retrieved_length\":<n>,…}\n\n# Example Domain\n…<truncated>"}</pre> |  | Demonstrates successful outbound fetch with no truncation. |
| `strata_ops_suite` | Ops: discover_server_actions, execute_action, get_action_details, handle_auth_failure, search_documentation.<br>Sample: `{"operation":"discover_server_actions","user_query":"status endpoints","server_names":[]}` | <pre>{"id":"strata","result":{"content":[{"text":"{'servers': {}}","type":"text"}],"structuredContent":{"result":{"servers":{}}}}}</pre> | <pre>{"result":{"servers":{}}}</pre> | <pre>{"result":{"servers":{"public_mcp_catalog":{"actions":[{"name":"list_servers",…},{"name":"refresh_server",…}]}}}}</pre> | Supply specific server names in future probes to exercise richer code paths. | Currently validates the empty-path schema. |
| `workspace_fs_read` | Ops: list_allowed_directories, directory_tree, list_directory, list_directory_with_sizes, calculate_directory_size, get_file_info, head_file, read_file, read_file_lines, read_text_file, read_media_file, read_multiple_media_files, read_multiple_text_files, find_duplicate_files, find_empty_directories, search_files, search_files_content.<br>Sample: `{"operation":"get_file_info","path":"/home/gabri/dev/stelae/README.md"}` | <pre>{"id":"fsinfo","result":{"content":[{"text":"size: 45908\ncreated: Mon Sep 29 2025 23:22:54 +01:00\nmodified: Sat Nov 15 2025 15:03:04 +00:00\naccessed: Sat Nov 15 2025 15:03:04 +00:00\nisDirectory: false\nisFile: true\npermissions: 0644\n","type":"text"}],"structuredContent":{"result":"size: 45908\ncreated: Mon Sep 29 2025 23:22:54 +01:00\nmodified: Sat Nov 15 2025 15:03:04 +00:00\naccessed: Sat Nov 15 2025 15:03:04 +00:00\nisDirectory: false\nisFile: true\npermissions: 0644\n"}}}</pre> | <pre>{"result":"size: 45908\ncreated: Mon Sep 29 2025 23:22:54 +01:00\nmodified: Sat Nov 15 2025 15:03:04 +00:00\naccessed: Sat Nov 15 2025 15:03:04 +00:00\nisDirectory: false\nisFile: true\npermissions: 0644\n"}</pre> | <pre>{"result":"size: <bytes>\ncreated: <timestamp>\nmodified: <timestamp>\naccessed: <timestamp>\nisDirectory: false\nisFile: true\npermissions: 0644\n"}</pre> |  | Verified the server’s allowed directory resolves to the repo after rerendering/restarting; relative paths still follow the proxy cwd, so prefer absolute ones. |
| `workspace_fs_write` | Ops: create_directory, move_file, edit_file, write_file, delete_file_content, insert_file_content, update_file_content, zip_directory, zip_files, unzip_file.<br>Sample: `{"operation":"create_directory","path":"/home/gabri/dev/stelae/dev/tmp/workspace-fs-write-test"}` | <pre>{"id":"fswrite","result":{"content":[{"text":"Successfully created directory /home/gabri/dev/stelae/dev/tmp/workspace-fs-write-test","type":"text"}],"structuredContent":{"result":"Successfully created directory /home/gabri/dev/stelae/dev/tmp/workspace-fs-write-test"}}}</pre> | <pre>{"result":"Successfully created directory /home/gabri/dev/stelae/dev/tmp/workspace-fs-write-test"}</pre> | <pre>{"result":"Successfully created directory /home/gabri/dev/stelae/dev/tmp/workspace-fs-write-test"}</pre> | Clean up scratch directories after each probe to keep the repo tidy. | Confirms write mode is active and scoped to `${STELAE_DIR}` (deleted the test directory after verification). |
| `workspace_shell_control` | Ops: execute_command, change_directory, get_current_directory, get_command_history.<br>Sample: `{"operation":"get_current_directory"}` | <pre>{"id":"shell","result":{"content":[{"text":"/home/gabri/apps/mcp-proxy","type":"text"}],"structuredContent":{"result":"/home/gabri/apps/mcp-proxy"}}}</pre> | <pre>{"result":"/home/gabri/apps/mcp-proxy"}</pre> | <pre>{"result":"${STELAE_DIR}"}</pre> | Need terminal controller (or a wrapper) that honors the new `--workdir {{STELAE_DIR}}` argument so subprocesses start inside the repo instead of inheriting the proxy cwd. | `config/bundles/starter_bundle.json` and the local proxy overlay now ship `--workdir {{STELAE_DIR}}`, but the upstream binary ignores it, so the runtime cwd still points at `~/apps/mcp-proxy`. |

These snapshots should make it easy to compare future clone-smoke results (e.g., ensuring the Docy wrapper keeps returning structured objects or checking whether `workspace_fs_read` ever points back at the Stelae repo). Use the companion log file whenever a full JSON diff is needed for troubleshooting.
