# Stelae MCP Tool Invocation Log - 2025-11-14

- Session opened against `http://127.0.0.1:9090/mcp` and every tool from the current `tools/list` payload was invoked via `tools/call`, per the AGENTS.md directive to rely on real MCP responses.
- Commands were issued with a small Python harness that reuses `dev/debug/chatgpt_connector_probe.py`; the raw "curl-style" transcript (full JSON for each HTTP request/response) lives at `dev/logs/tool_invocations/20251114T104345Z-tool-calls.json`.
- Each tool was also invoked through the MCP bridge (`mcp__stelae__*` adapters) so we can capture what Codex sees when it calls the tool directly; those outputs are summarized below and can be reproduced by reusing the same adapters.
- Follow-up captures for the `manage_docy_sources` serialization fix live at `dev/logs/tool_invocations/20251114T225700Z-manage_docy_sources.json`.
- The table now compares both perspectives so we can spot gaps (double-encoding, schema validation errors, discovery drift, etc.) without rerunning the probes.

### Logging method

- Each table row now records the literal JSON (trimmed) returned by the proxy via `curl` and by the MCP adapter (`mcp__stelae__*`). This makes it obvious when schema translations drift away from expectations.
- JSON snippets are abbreviated for readability: `…` indicates removed keys/entries, and `<truncated>` marks shortened string bodies. Keep identifiers (`id`, `structuredContent`, etc.) intact so schema diffs remain meaningful.
- Capture the `curl` column with the exact JSON-RPC payload sent to `/mcp`, piped through `jq` (trim large text manually if needed). Capture the MCP column by calling the adapter directly and copying the resulting JSON (again trimming only the `text` payloads).
- When logging future runs, prefer deterministic sample arguments so the snippets remain comparable clone-to-clone.

| Tool | Operation / arguments | curl JSON excerpt | Direct MCP JSON excerpt | Expected response | Required fixes | Notes |
| --- | --- | --- | --- | --- | --- | --- |
| `doc_fetch_suite` | `{"operation":"list_documentation_sources_tool"}` | <pre>{"id":"docfetch-list","result":{"content":[{"text":"Available documentation sources:[ARCH…, README…, https://www.example.com]","type":"text"}],"structuredContent":{"result":"Available documentation sources:[ARCH…, README…, https://www.example.com]"}}}</pre> | <pre>{"result":"Available documentation sources:[ARCH…, README…, https://www.example.com]"}</pre> | Should enumerate the Docy overlay entries (README, architecture guide, diagnostics placeholder). |  | Confirms Docy + fetch wrapper now read directly from `${STELAE_CONFIG_HOME}`. |
| `doc_fetch_suite` | `{"operation":"fetch_documentation_page","url":"https://www.example.com"}` | <pre>{"id":"docfetch-example","result":{"content":[{"text":"# Example Domain\n…","type":"text"}],"structuredContent":{"result":"# Example Domain\n…"}}}</pre> | <pre>{"result":"# Example Domain\nThis domain is for use in documentation examples…<truncated>"}</pre> | Should stream the placeholder markdown so agents can verify Docy health without publishing repo docs remotely. |  | Placeholder doubles as a regression test for the fetch pipeline. |
| `grep` | `{"pattern":"Stelae","paths":["README.md"],"recursive":false,"max_count":5}` | <pre>{"id":"grep1","result":{"content":[{"text":"{\"content\":[{\"type\":\"text\",\"text\":\"No matches found\"}],\"isError\":false}","type":"text"}],"structuredContent":{"result":{"content":[{"text":"No matches found","type":"text"}],"isError":false}}}}</pre> | <pre>{"result":{"content":[{"text":"No matches found","type":"text"}],"isError":false}}</pre> | Should stream ripgrep hits (or an empty set) from `${STELAE_DIR}`. |  | Wrapper still emits JSON-in-text for the `content` block, but structuredContent is correct. |
| `manage_docy_sources` | `{"operation":"list_sources"}` | <pre>{"id":"docylist","result":{"content":[{"text":"{'sources':[{'id':'stelae-architecture-guide',…},{'id':'stelae-tool-invocation-log','url':'https://www.example.com'}],'catalogPath':'/home/gabri/.config/stelae/docy_sources.local.json','urlFile':'/home/gabri/.config/stelae/.state/docy/.docy.urls'}","type":"text"}],"structuredContent":{"result":{"catalogPath":"/home/gabri/.config/stelae/docy_sources.local.json","sources":[…],"urlFile":"/home/gabri/.config/stelae/.state/docy/.docy.urls"}}}}</pre> | <pre>{"result":{"catalogPath":"/home/gabri/.config/stelae/docy_sources.local.json","sources":[{"id":"stelae-architecture-guide",…},{"id":"stelae-mcp-stack-readme",…},{"id":"stelae-tool-invocation-log","url":"https://www.example.com"}],"urlFile":"/home/gabri/.config/stelae/.state/docy/.docy.urls"}}</pre> | Should surface the fully seeded Docy overlay. |  | Shows the placeholder diagnostics entry without touching tracked templates. |
| `manage_stelae` | `{"operation":"list_discovered_servers"}` | <pre>{"id":"manage-stelae","result":{"content":[{"text":"{\"status\":\"ok\",\"details\":{\"servers\":[],\"path\":\"/home/gabri/.config/stelae/.state/discovered_servers.json\"},…}","type":"text"}],"structuredContent":{"result":{"status":"ok","details":{"servers":[],"path":"/home/gabri/.config/stelae/.state/discovered_servers.json"},…}}}}</pre> | <pre>{"result":{"status":"ok","details":{"servers":[{"name":"apecloud-aperag",…},{"name":"public_mcp_catalog",…},{"name":"qdrant",…},…],"path":"${STELAE_STATE_HOME}/discovered_servers.json"},"files_updated":[],"commands_run":[],"warnings":[],"errors":[]}}</pre> | Should include any cached discovery descriptors with the standard status/details envelope. | Rerun discovery (or refresh the overlay) so the proxy path returns the same populated list as the adapter. | Adapter confirms entries exist even though the proxy surface is still empty. |
| `memory_suite` | `{"operation":"list_memory_projects"}` | <pre>{"id":"mem-list","result":{"content":[{"text":"Error executing tool memory_suite: Proxy reported error for list_memory_projects: {\"code\":-32601,\"message\":\"Unknown tool: list_memory_projects\"}","type":"text"}],"structuredContent":{"result":"Error executing tool memory_suite: Proxy reported error for list_memory_projects: {\"code\":-32601,\"message\":\"Unknown tool: list_memory_projects\"}"},"isError":true}}</pre> | <pre>{"result":"Error executing tool memory_suite: Proxy reported error for list_memory_projects: {\"code\":-32601,\"message\":\"Unknown tool: list_memory_projects\"}"}</pre> | Should enumerate Basic Memory projects and mark the current/default workspace. | Install/launch the Basic Memory server (or rerun the starter bundle installer) so the wrapped operations exist again. | Both pathways currently fail because the downstream tool is missing. |
| `scrapling_fetch_suite` | `{"operation":"s_fetch_page","url":"https://example.com","mode":"basic","format":"markdown","max_length":2000}` | <pre>{"id":"scrapling","result":{"content":[{"text":"METADATA:{\"total_length\":171,…}\n\n# Example Domain\n…","type":"text"}],"structuredContent":{"result":"METADATA:{\"total_length\":171,…}\n\n# Example Domain\n…"}}}</pre> | <pre>{"result":"METADATA:{\"total_length\":171,\"retrieved_length\":171,…}\n\n# Example Domain\n…<truncated>"}</pre> | Should return metadata + markdown body per the Scrapling schema note. |  | Demonstrates successful outbound fetch with no truncation. |
| `strata_ops_suite` | `{"operation":"discover_server_actions","user_query":"status endpoints","server_names":[]}` | <pre>{"id":"strata","result":{"content":[{"text":"{'servers': {}}","type":"text"}],"structuredContent":{"result":{"servers":{}}}}}</pre> | <pre>{"result":{"servers":{}}}</pre> | Should enumerate actions once real `server_names` are provided. | Supply specific server names in future probes to exercise richer code paths. | Currently validates the empty-path schema. |
| `workspace_fs_read` | `{"operation":"get_file_info","path":"/home/gabri/dev/stelae/README.md"}` | <pre>{"id":"fsinfo","result":{"content":[{"text":"size: 45908\ncreated: Mon Sep 29 2025 23:22:54 +01:00\nmodified: Sat Nov 15 2025 15:03:04 +00:00\naccessed: Sat Nov 15 2025 15:03:04 +00:00\nisDirectory: false\nisFile: true\npermissions: 0644\n","type":"text"}],"structuredContent":{"result":"size: 45908\ncreated: Mon Sep 29 2025 23:22:54 +01:00\nmodified: Sat Nov 15 2025 15:03:04 +00:00\naccessed: Sat Nov 15 2025 15:03:04 +00:00\nisDirectory: false\nisFile: true\npermissions: 0644\n"}}}</pre> | <pre>{"result":"size: 45908\ncreated: Mon Sep 29 2025 23:22:54 +01:00\nmodified: Sat Nov 15 2025 15:03:04 +00:00\naccessed: Sat Nov 15 2025 15:03:04 +00:00\nisDirectory: false\nisFile: true\npermissions: 0644\n"}</pre> | Should inspect files inside `${STELAE_DIR}` (pass absolute paths to guarantee we stay in this repo). |  | Verified the server’s allowed directory resolves to the repo after rerendering/restarting; relative paths still follow the proxy cwd, so prefer absolute ones. |
| `workspace_fs_write` | `{"operation":"create_directory","path":"/home/gabri/dev/stelae/dev/tmp/workspace-fs-write-test"}` | <pre>{"id":"fswrite","result":{"content":[{"text":"Successfully created directory /home/gabri/dev/stelae/dev/tmp/workspace-fs-write-test","type":"text"}],"structuredContent":{"result":"Successfully created directory /home/gabri/dev/stelae/dev/tmp/workspace-fs-write-test"}}}</pre> | <pre>{"result":"Successfully created directory /home/gabri/dev/stelae/dev/tmp/workspace-fs-write-test"}</pre> | Should succeed now that the filesystem server runs with `--allow-write`. | Clean up scratch directories after each probe to keep the repo tidy. | Confirms write mode is active and scoped to `${STELAE_DIR}` (deleted the test directory after verification). |
| `workspace_shell_control` | `{"operation":"get_current_directory"}` | <pre>{"id":"shell","result":{"content":[{"text":"/home/gabri/apps/mcp-proxy","type":"text"}],"structuredContent":{"result":"/home/gabri/apps/mcp-proxy"}}}</pre> | <pre>{"result":"/home/gabri/apps/mcp-proxy"}</pre> | Should report `PHOENIX_ROOT` (from `.env`) so shell commands operate inside the intended workspace. | Update the shell MCP launch args (`--workdir`) before the next probe. | Confirms the controller is still scoped to the proxy checkout. |

These snapshots should make it easy to compare future clone-smoke results (e.g., ensuring the Docy wrapper keeps returning structured objects or checking whether `workspace_fs_read` ever points back at the Stelae repo). Use the companion log file whenever a full JSON diff is needed for troubleshooting.
