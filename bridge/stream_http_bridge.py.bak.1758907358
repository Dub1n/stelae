#!/usr/bin/env python3
"""
Streamable HTTP bridge for MCP (no upstream SSE required).

- GET/HEAD /mcp  -> opens SSE stream; sends one-time synthetic `event: endpoint`
                    pointing clients to this bridge's public /mcp; emits periodic
                    keepalives so Cloudflare won't idle the connection.
- POST     /mcp  -> forwards JSON-RPC to a fixed upstream POST endpoint.
                    We support auto-probing candidates and following a single redirect.
- GET   /healthz -> liveness + quick upstream manifest reachability check
- GET   /version -> bridge metadata
- GET   /debug/upstream -> shows chosen upstream path/candidates
- GET   /debug/routes   -> proxies upstream /openapi.json (if present)
- GET   /debug/scan     -> actively probes candidate POST paths and returns results

Everything else reverse-proxies to UPSTREAM_BASE (on :9092 by default).
"""

import asyncio
import logging
import os
import sys
import time
import uuid
from typing import Dict, List, Optional
from urllib.parse import urljoin, urlparse

import httpx
from starlette.applications import Starlette
from starlette.middleware.cors import CORSMiddleware
from starlette.requests import Request
from starlette.responses import (
    JSONResponse,
    PlainTextResponse,
    Response,
    StreamingResponse,
)
from starlette.routing import Route

# -----------------------------------------------------------------------------
# config & globals
# -----------------------------------------------------------------------------

logger = logging.getLogger("bridge")
logger.setLevel(logging.INFO)

BRIDGE_VERSION = "stelae-bridge/0.3.3-fixglobals+scan"

UPSTREAM_BASE = os.environ.get("UPSTREAM_BASE", "http://127.0.0.1:9092")

# If not provided, we'll probe PATH_CANDIDATES at startup.
UPSTREAM_POST_PATH = os.environ.get("UPSTREAM_POST_PATH")

# broaden the search a bit; we try both with and without trailing slash
DEFAULT_CANDIDATES = "/mcp,/mem,/rpc,/jsonrpc,/batch,/"
PATH_CANDIDATES: List[str] = [
    p.strip()
    for p in os.environ.get("UPSTREAM_PATH_CANDIDATES", DEFAULT_CANDIDATES).split(",")
    if p.strip()
]

PROBE_TIMEOUT = float(os.environ.get("UPSTREAM_PROBE_TIMEOUT", "2.5"))

UPSTREAM_MANIFEST = os.environ.get(
    "UPSTREAM_MANIFEST",
    urljoin(UPSTREAM_BASE, "/.well-known/mcp/manifest.json"),
)

PUBLIC_BASE_URL = os.environ.get("PUBLIC_BASE_URL", "https://mcp.infotopology.xyz")
PUBLIC_POST_URL = urljoin(PUBLIC_BASE_URL, "/mcp")

SESSION_COOKIE = "mcp_session"
SESSION_ENDPOINTS: Dict[str, str] = {}

KEEPALIVE_INTERVAL = float(os.environ.get("KEEPALIVE_INTERVAL", "10"))  # seconds


# set at import-time; may be promoted at runtime by redirect/failover
def _normalize_path(p: str) -> str:
    if not p:
        return "/"
    if not p.startswith("/"):
        p = "/" + p
    return p


def _variants_for(path: str) -> List[str]:
    """return normalized path variants with and without trailing slash."""
    p = _normalize_path(path)
    return [p, p if p.endswith("/") else p + "/"]


def _clip(s: str, n: int = 512) -> str:
    return s if len(s) <= n else s[:n] + "...<truncated>"


def _safe_media_type(headers: httpx.Headers, default: str = "application/json") -> str:
    return headers.get("content-type", default)


# -----------------------------------------------------------------------------
# probe
# -----------------------------------------------------------------------------


def _probe_upstream_path() -> Optional[str]:
    """
    Try candidate paths (both with and without trailing slash) with a benign
    JSON-RPC `initialize`. Follow one redirect if provided. Return the first
    path that yields 2xx, else None.
    """
    payload = {
        "jsonrpc": "2.0",
        "id": "probe",
        "method": "initialize",
        "params": {"protocolVersion": "2024-11-05"},
    }
    for base_path in PATH_CANDIDATES:
        for path_try in _variants_for(base_path):
            url = urljoin(UPSTREAM_BASE, path_try.lstrip("/"))
            try:
                with httpx.Client(timeout=PROBE_TIMEOUT) as client:
                    r = client.post(
                        url, json=payload, headers={"Accept": "application/json"}
                    )
                if 200 <= r.status_code < 300:
                    logger.info(
                        "[bridge] upstream path OK: %s (%s)", path_try, r.status_code
                    )
                    return path_try
                if (
                    r.status_code in (301, 302, 303, 307, 308)
                    and "location" in r.headers
                ):
                    loc = r.headers["location"]
                    alt_url = (
                        loc
                        if loc.startswith("http")
                        else urljoin(UPSTREAM_BASE, loc.lstrip("/"))
                    )
                    try:
                        with httpx.Client(timeout=PROBE_TIMEOUT) as client:
                            r2 = client.post(
                                alt_url,
                                json=payload,
                                headers={"Accept": "application/json"},
                            )
                        if 200 <= r2.status_code < 300:
                            parsed = urlparse(alt_url)
                            alt_path = parsed.path or "/"
                            logger.info(
                                "[bridge] upstream redirect OK: %s (%s)",
                                alt_path,
                                r2.status_code,
                            )
                            return alt_path
                    except Exception as e2:
                        logger.info(
                            "[bridge] redirect probe failed for %s: %s", alt_url, e2
                        )
                logger.info(
                    "[bridge] upstream path %s returned %s", path_try, r.status_code
                )
            except Exception as e:
                logger.info("[bridge] upstream path %s probe failed: %s", path_try, e)
    return None


if not UPSTREAM_POST_PATH:
    chosen = _probe_upstream_path()
    UPSTREAM_POST_PATH = chosen or "/mcp"
    logger.info("[bridge] using UPSTREAM_POST_PATH=%s", UPSTREAM_POST_PATH)

UPSTREAM_POST_PATH = _normalize_path(UPSTREAM_POST_PATH)
UPSTREAM_POST_URL = urljoin(UPSTREAM_BASE, UPSTREAM_POST_PATH.lstrip("/"))

# -----------------------------------------------------------------------------
# helpers
# -----------------------------------------------------------------------------


async def ensure_session_ready(sid: str) -> bool:
    """
    In 'no upstream stream' mode, there's nothing to wait for.
    We just record the fixed upstream POST endpoint for this session.
    """
    if SESSION_ENDPOINTS.get(sid):
        return True
    SESSION_ENDPOINTS[sid] = UPSTREAM_POST_URL
    return True


# -----------------------------------------------------------------------------
# routes
# -----------------------------------------------------------------------------


async def sse_head(_: Request) -> Response:
    headers = {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache, no-transform",
        "Connection": "keep-alive",
    }
    return Response(status_code=200, headers=headers)


async def sse_bridge(request: Request) -> Response:
    sid = request.cookies.get(SESSION_COOKIE) or uuid.uuid4().hex

    async def event_gen():
        # immediately hint the client where to POST (our public /mcp)
        yield f"event: endpoint\ndata: {PUBLIC_POST_URL}\n\n"
        while True:
            await asyncio.sleep(KEEPALIVE_INTERVAL)
            yield f": keepalive {int(time.time())}\n\n"

    headers = {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache, no-transform",
        "Connection": "keep-alive",
    }
    resp = StreamingResponse(event_gen(), headers=headers, status_code=200)
    resp.set_cookie(SESSION_COOKIE, sid, httponly=False, samesite="Lax")
    return resp


async def post_mcp(request: Request) -> Response:
    # we mutate the chosen path/url if we discover a better one at runtime
    global UPSTREAM_POST_PATH, UPSTREAM_POST_URL

    # accept only JSON
    try:
        payload = await request.json()
    except Exception:
        return JSONResponse({"error": "invalid JSON"}, status_code=400)

    # establish-session (record upstream URL for this sid)
    sid = (
        request.cookies.get(SESSION_COOKIE)
        or request.headers.get("MCP-Session")
        or uuid.uuid4().hex
    )
    await ensure_session_ready(sid)
    endpoint = SESSION_ENDPOINTS.get(sid, UPSTREAM_POST_URL)

    # annotate responses for easier debugging
    resp_headers = {
        "X-Bridge-Upstream-Path": UPSTREAM_POST_PATH,
        "X-Bridge-Upstream-URL": endpoint,
    }

    # forward to upstream fixed endpoint (with one-shot redirect/failover)
    async with httpx.AsyncClient(timeout=httpx.Timeout(30, read=30)) as client:
        try:
            r = await client.post(
                endpoint, json=payload, headers={"Accept": "application/json"}
            )
        except Exception as e:
            return JSONResponse(
                {"error": f"upstream post failed: {e}"},
                status_code=502,
                headers=resp_headers,
            )

    # follow one redirect and promote the working path
    if r.status_code in (301, 302, 303, 307, 308) and "location" in r.headers:
        loc = r.headers["location"]
        alt_url = (
            loc if loc.startswith("http") else urljoin(UPSTREAM_BASE, loc.lstrip("/"))
        )
        try:
            async with httpx.AsyncClient(timeout=httpx.Timeout(30, read=30)) as client:
                r2 = await client.post(
                    alt_url, json=payload, headers={"Accept": "application/json"}
                )
            if r2.status_code < 400:
                parsed = urlparse(alt_url)
                UPSTREAM_POST_URL = alt_url
                UPSTREAM_POST_PATH = parsed.path or "/"
                SESSION_ENDPOINTS.clear()
                resp_headers["X-Bridge-Upstream-Path"] = UPSTREAM_POST_PATH
                resp_headers["X-Bridge-Upstream-URL"] = UPSTREAM_POST_URL
                r = r2
        except Exception:
            pass

    # wrong path/method? try other candidates incl. trailing slash
    if r.status_code in (404, 405):
        candidates: List[str] = []
        for p in PATH_CANDIDATES:
            for v in _variants_for(p):
                if v not in candidates:
                    candidates.append(v)

        current_path = urlparse(endpoint).path or "/"
        ordered = [
            p for p in candidates if p != current_path
        ]  # skip what we just tried

        async with httpx.AsyncClient(timeout=httpx.Timeout(30, read=30)) as client:
            for alt in ordered:
                alt_url = urljoin(UPSTREAM_BASE, alt.lstrip("/"))
                try:
                    r2 = await client.post(
                        alt_url, json=payload, headers={"Accept": "application/json"}
                    )
                    if r2.status_code < 400:
                        UPSTREAM_POST_PATH, UPSTREAM_POST_URL = alt, alt_url
                        SESSION_ENDPOINTS.clear()
                        resp_headers["X-Bridge-Upstream-Path"] = UPSTREAM_POST_PATH
                        resp_headers["X-Bridge-Upstream-URL"] = UPSTREAM_POST_URL
                        r = r2
                        break
                except Exception:
                    continue

    # on error: return upstream status + body (so callers can see details)
    if r.status_code >= 400:
        resp_headers["X-Bridge-Upstream-Status"] = str(r.status_code)
        return Response(
            content=r.content,
            status_code=502,
            headers={**resp_headers, "Content-Type": _safe_media_type(r.headers)},
        )

    # success: pass upstream body and status through
    resp_headers["X-Bridge-Upstream-Status"] = str(r.status_code)
    return Response(
        content=r.content,
        status_code=r.status_code,
        headers={**resp_headers, "Content-Type": _safe_media_type(r.headers)},
    )


async def healthz(_: Request) -> Response:
    """Liveness + quick upstream manifest reachability (tight timeout)."""
    started = time.time()
    upstream_ok = False
    upstream_status = None
    try:
        async with httpx.AsyncClient(timeout=httpx.Timeout(0.5, read=0.5)) as client:
            resp = await client.get(
                UPSTREAM_MANIFEST, headers={"Accept": "application/json"}
            )
            upstream_status = resp.status_code
            upstream_ok = resp.status_code == 200
    except Exception:
        upstream_ok = False
    payload = {
        "status": "ok",
        "bridge": BRIDGE_VERSION,
        "elapsed_ms": int((time.time() - started) * 1000),
        "upstream": {
            "base": UPSTREAM_BASE,
            "manifest": UPSTREAM_MANIFEST,
            "postPath": UPSTREAM_POST_PATH,
            "postUrl": UPSTREAM_POST_URL,
            "reachable": upstream_ok,
            "status": upstream_status,
        },
    }
    return JSONResponse(payload, status_code=200)


async def version(_: Request) -> Response:
    info = {
        "bridge": BRIDGE_VERSION,
        "python": sys.version.split()[0],
        "upstreamBaseURL": UPSTREAM_BASE,
        "publicBaseURL": PUBLIC_BASE_URL,
        "protocolHint": "2024-11-05",
        "routes": [
            "/mcp (GET,HEAD,POST)",
            "/healthz",
            "/version",
            "/debug/upstream",
            "/debug/routes",
            "/debug/scan",
            "reverse-proxy /*",
        ],
        "mode": "fixed-upstream-post+autoprobe",
        "upstreamPostPath": UPSTREAM_POST_PATH,
        "upstreamPathCandidates": PATH_CANDIDATES,
        "probeTimeout": PROBE_TIMEOUT,
    }
    return JSONResponse(info, status_code=200)


async def reverse_proxy(request: Request) -> Response:
    target = urljoin(UPSTREAM_BASE, request.url.path)
    if request.url.query:
        target = f"{target}?{request.url.query}"

    headers = {
        k: v
        for k, v in request.headers.items()
        if k.lower() not in {"host", "content-length"}
    }
    method = request.method.upper()

    async with httpx.AsyncClient(timeout=httpx.Timeout(None, read=None)) as client:
        if method in {"GET", "HEAD"}:
            try:
                async with client.stream(method, target, headers=headers) as resp:
                    return StreamingResponse(
                        resp.aiter_raw(),
                        status_code=resp.status_code,
                        headers={
                            k: v
                            for k, v in resp.headers.items()
                            if k.lower() != "transfer-encoding"
                        },
                    )
            except httpx.HTTPError as e:
                return PlainTextResponse(str(e), status_code=502)
        else:
            body = await request.body()
            try:
                async with client.stream(
                    method, target, headers=headers, content=body
                ) as resp:
                    data = await resp.aread()
                    return Response(
                        content=data,
                        status_code=resp.status_code,
                        headers={
                            k: v
                            for k, v in resp.headers.items()
                            if k.lower() != "transfer-encoding"
                        },
                    )
            except httpx.HTTPError as e:
                return PlainTextResponse(str(e), status_code=502)


async def debug_upstream(_: Request) -> Response:
    info = {
        "base": UPSTREAM_BASE,
        "postPath": UPSTREAM_POST_PATH,
        "postUrl": UPSTREAM_POST_URL,
        "candidates": PATH_CANDIDATES,
        "probeTimeout": PROBE_TIMEOUT,
        "publicBaseURL": PUBLIC_BASE_URL,
    }
    return JSONResponse(info, status_code=200)


async def debug_routes(_: Request) -> Response:
    try:
        async with httpx.AsyncClient(timeout=httpx.Timeout(2, read=2)) as client:
            r = await client.get(urljoin(UPSTREAM_BASE, "/openapi.json"))
        return Response(
            content=r.content,
            status_code=r.status_code,
            media_type=_safe_media_type(r.headers, "application/json"),
        )
    except Exception as e:
        return JSONResponse({"error": f"route probe failed: {e}"}, status_code=502)


async def debug_scan(_: Request) -> Response:
    """
    Actively test candidate POST paths, following one redirect. Returns a table of results.
    """
    payload = {
        "jsonrpc": "2.0",
        "id": "scan",
        "method": "initialize",
        "params": {"protocolVersion": "2024-11-05"},
    }
    results = []
    async with httpx.AsyncClient(timeout=httpx.Timeout(4, read=4)) as client:
        for base_path in PATH_CANDIDATES:
            for p in _variants_for(base_path):
                url = urljoin(UPSTREAM_BASE, p.lstrip("/"))
                entry = {"path": p, "url": url}
                try:
                    r = await client.post(
                        url, json=payload, headers={"Accept": "application/json"}
                    )
                    entry["status"] = r.status_code
                    if (
                        r.status_code in (301, 302, 303, 307, 308)
                        and "location" in r.headers
                    ):
                        loc = r.headers["location"]
                        alt_url = (
                            loc
                            if loc.startswith("http")
                            else urljoin(UPSTREAM_BASE, loc.lstrip("/"))
                        )
                        try:
                            r2 = await client.post(
                                alt_url,
                                json=payload,
                                headers={"Accept": "application/json"},
                            )
                            entry["redirect_to"] = alt_url
                            entry["redirect_status"] = r2.status_code
                            if r2.content:
                                entry["body"] = _clip(r2.text)
                        except Exception as e2:
                            entry["redirect_error"] = str(e2)
                    else:
                        if r.content:
                            entry["body"] = _clip(r.text)
                except Exception as e:
                    entry["error"] = str(e)
                results.append(entry)
    return JSONResponse({"base": UPSTREAM_BASE, "results": results}, status_code=200)


routes = [
    Route("/mcp", sse_head, methods=["HEAD"]),
    Route("/mcp", sse_bridge, methods=["GET"]),
    Route("/mcp", post_mcp, methods=["POST"]),
    Route("/healthz", healthz, methods=["GET"]),
    Route("/version", version, methods=["GET"]),
    Route("/debug/upstream", debug_upstream, methods=["GET"]),
    Route("/debug/routes", debug_routes, methods=["GET"]),
    Route("/debug/scan", debug_scan, methods=["GET"]),
    Route(
        "/{path:path}",
        reverse_proxy,
        methods=["GET", "POST", "PUT", "PATCH", "DELETE", "HEAD", "OPTIONS"],
    ),
]

app = Starlette(routes=routes)

# relaxed CORS during bring-up (tighten later if you want)
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["GET", "POST", "OPTIONS", "HEAD"],
    allow_headers=["*"],
)
