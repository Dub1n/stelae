#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Stelae MCP Bridge - HTTP+SSE auto-probing bridge for ChatGPT Connector compliance.

- Public endpoints (behind Cloudflare):
    GET  /mcp            -> proxy SSE to upstream /{server}/sse
    POST /mcp            -> forward JSON-RPC to upstream discovered POST route
    GET  /healthz        -> simple health with probe status
    GET  /version        -> bridge + env info
    GET  /debug/upstream -> current upstream config
    GET  /debug/routes   -> list of bridge routes
    GET  /debug/scan     -> run full probe & show results

- Upstream (local proxy):
    Base: http://127.0.0.1:9092
    Manifest: /.well-known/mcp/manifest.json
    SSE: /{server}/sse
    POST candidates: /{server}, /{server}/, /{server}/message, /{server}/messages, /{server}/rpc, /{server}/jsonrpc, /{server}/send
    Envelopes tried for POST:
        - json            : body = payload (application/json)
        - text            : body = raw json string (text/plain)
        - ndjson          : body = json + '\n' (application/x-ndjson)
        - wrapped         : {"message": payload} (application/json)
        - type_wrapped    : {"type":"message","data": payload} (application/json)
        - form            : data=urlencode({"data": json}) (application/x-www-form-urlencoded)

This bridge follows upstream redirects (3xx) during probing and does **not** leak them to clients.
"""

import asyncio
import json
import os
from typing import Any, Dict, List, Optional, Tuple

import httpx
from fastapi import FastAPI, Request, Response
from fastapi.responses import JSONResponse, PlainTextResponse, StreamingResponse
from starlette.middleware.cors import CORSMiddleware
from starlette.routing import Route

# ----------------------------
# Configuration
# ----------------------------

BRIDGE_VERSION = os.environ.get("BRIDGE_VERSION", "stelae-bridge/0.4.0-autoprobe")
PUBLIC_BASE = os.environ.get("PUBLIC_BASE_URL", "https://mcp.infotopology.xyz")
UPSTREAM_BASE = os.environ.get("UPSTREAM_BASE_URL", "http://127.0.0.1:9092")
MANIFEST_PATH = "/.well-known/mcp/manifest.json"
PROBE_TIMEOUT = float(os.environ.get("PROBE_TIMEOUT", "2.5"))
DEFAULT_PROTOCOL_HINT = "2024-11-05"

# Preferred default server for MCP post/SSE
PREFERRED_SERVER = os.environ.get("PREFERRED_SERVER", "mem")

# Candidate POST paths per server
POST_PATH_TEMPLATES = [
    "/{name}",
    "/{name}/",
    "/{name}/message",
    "/{name}/messages",
    "/{name}/rpc",
    "/{name}/jsonrpc",
    "/{name}/send",
]


# Envelope/format strategies to try (in this order)
def build_envelopes(payload: Dict[str, Any]) -> List[Tuple[str, Dict[str, str], bytes]]:
    raw = json.dumps(payload).encode("utf-8")
    return [
        # 1) application/json (raw JSON-RPC)
        ("json", {"Content-Type": "application/json"}, raw),
        # 2) text/plain (raw JSON string)
        ("text", {"Content-Type": "text/plain"}, raw),
        # 3) NDJSON
        ("ndjson", {"Content-Type": "application/x-ndjson"}, raw + b"\n"),
        # 4) {"message": <jsonrpc>}
        (
            "wrapped",
            {"Content-Type": "application/json"},
            json.dumps({"message": payload}).encode("utf-8"),
        ),
        # 5) {"type":"message","data": <jsonrpc>}
        (
            "type_wrapped",
            {"Content-Type": "application/json"},
            json.dumps({"type": "message", "data": payload}).encode("utf-8"),
        ),
        # 6) x-www-form-urlencoded data=<json>
        (
            "form",
            {"Content-Type": "application/x-www-form-urlencoded"},
            b"data=" + httpx.QueryParams({"data": raw.decode("utf-8")}).encode(),
        ),
    ]


# A tiny test JSON-RPC we can safely send
PROBE_RPC = {
    "jsonrpc": "2.0",
    "id": "probe",
    "method": "initialize",
    "params": {"protocolVersion": DEFAULT_PROTOCOL_HINT},
}

# ----------------------------
# App & shared state
# ----------------------------

app = FastAPI(title="Stelae MCP Bridge", version=BRIDGE_VERSION)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_headers=["*"],
    allow_methods=["*"],
)


class UpstreamConfig:
    def __init__(self) -> None:
        self.server_names: List[str] = []
        self.default_server: Optional[str] = None
        self.sse_path: Optional[str] = None  # e.g. /mem/sse
        self.post_path: Optional[str] = None  # e.g. /mem/message
        self.post_mode: Optional[str] = None  # which envelope worked
        self.probe_results: List[Dict[str, Any]] = []
        self.manifest_ok: bool = False

    def to_dict(self) -> Dict[str, Any]:
        return {
            "base": UPSTREAM_BASE,
            "manifest": f"{UPSTREAM_BASE}{MANIFEST_PATH}",
            "serverNames": self.server_names,
            "defaultServer": self.default_server,
            "ssePath": self.sse_path,
            "postPath": self.post_path,
            "postMode": self.post_mode,
            "manifestOk": self.manifest_ok,
            "probeResults": self.probe_results,
        }


STATE = UpstreamConfig()
HTTP = httpx.AsyncClient(
    timeout=PROBE_TIMEOUT, follow_redirects=True, headers={"X-Bridge": "stelae"}
)

# ----------------------------
# Utilities
# ----------------------------


async def fetch_manifest() -> Dict[str, Any]:
    url = f"{UPSTREAM_BASE}{MANIFEST_PATH}"
    r = await HTTP.get(url)
    r.raise_for_status()
    return r.json()


async def discover_servers() -> List[str]:
    try:
        m = await fetch_manifest()
        STATE.manifest_ok = True
    except Exception:
        STATE.manifest_ok = False
        return []
    srv_urls = []
    servers = m.get("servers", [])
    for s in servers:
        u = s.get("url")
        if not isinstance(u, str):
            continue
        # Expect .../{name}/sse
        # Extract the {name} component
        parts = u.strip("/").split("/")
        if parts and parts[-1] == "sse" and len(parts) >= 2:
            srv_urls.append(parts[-2])
    return sorted(set(srv_urls))


def choose_default_server(names: List[str]) -> Optional[str]:
    if not names:
        return None
    if PREFERRED_SERVER in names:
        return PREFERRED_SERVER
    return names[0]


async def probe_post_endpoint(
    server: str,
) -> Tuple[Optional[str], Optional[str], List[Dict[str, Any]]]:
    """
    Try all path patterns and envelope modes; return (post_path, mode, results)
    """
    results: List[Dict[str, Any]] = []
    payload = PROBE_RPC
    envelopes = build_envelopes(payload)
    success_statuses = {200, 201, 202, 204}
    for tpl in POST_PATH_TEMPLATES:
        path = tpl.format(name=server)
        url = f"{UPSTREAM_BASE}{path}"
        for mode, headers, body in envelopes:
            try:
                r = await HTTP.post(url, content=body, headers=headers)
                results.append({"path": path, "mode": mode, "status": r.status_code})
                if r.status_code in success_statuses:
                    return path, mode, results
            except Exception as e:
                results.append({"path": path, "mode": mode, "error": str(e)})
                continue
    return None, None, results


async def ensure_config() -> None:
    """
    Populate STATE on first use; safe to call multiple times.
    """
    if STATE.default_server and STATE.sse_path and STATE.post_path and STATE.post_mode:
        return

    names = await discover_servers()
    STATE.server_names = names
    default_server = choose_default_server(names)
    STATE.default_server = default_server
    if default_server:
        STATE.sse_path = f"/{default_server}/sse"
        post_path, post_mode, results = await probe_post_endpoint(default_server)
        STATE.post_path = post_path
        STATE.post_mode = post_mode
        STATE.probe_results = results
    else:
        STATE.sse_path = None
        STATE.post_path = None
        STATE.post_mode = None
        STATE.probe_results = []


def _wrap_body(mode: str, data: bytes) -> Tuple[Dict[str, str], bytes]:
    # Convert incoming JSON bytes into the envelope used during probing
    try:
        payload = json.loads(data.decode("utf-8"))
    except Exception:
        # If not JSON, pass-through text/plain
        return {"Content-Type": "text/plain"}, data

    envelopes = dict((m, (h, b)) for (m, h, b) in build_envelopes(payload))
    headers, body = envelopes.get(mode, envelopes["json"])
    return headers, body


# ----------------------------
# Routes
# ----------------------------


@app.get("/healthz")
async def healthz():
    try:
        await ensure_config()
        upstream_ok = bool(STATE.default_server and STATE.sse_path)
        reachable = False
        status_code = None
        if STATE.post_path:
            # poke a HEAD/GET on post_path just to see if host is up
            try:
                r = await HTTP.get(f"{UPSTREAM_BASE}{STATE.post_path}")
                status_code = r.status_code
                reachable = True
            except Exception:
                reachable = False
        return JSONResponse(
            {
                "status": "ok",
                "bridge": BRIDGE_VERSION,
                "elapsed_ms": 0,
                "upstream": {
                    "base": UPSTREAM_BASE,
                    "manifest": f"{UPSTREAM_BASE}{MANIFEST_PATH}",
                    "postPath": STATE.post_path,
                    "postMode": STATE.post_mode,
                    "reachable": reachable,
                    "status": status_code,
                },
                "server": STATE.default_server,
            }
        )
    except Exception as e:
        return JSONResponse({"status": "error", "error": str(e)}, status_code=500)


@app.get("/version")
async def version():
    await ensure_config()
    return JSONResponse(
        {
            "bridge": BRIDGE_VERSION,
            "python": "{}.{}.{}".format(*tuple(__import__("sys").version_info[:3])),
            "upstreamBaseURL": UPSTREAM_BASE,
            "publicBaseURL": PUBLIC_BASE,
            "protocolHint": DEFAULT_PROTOCOL_HINT,
            "routes": [r.path for r in app.router.routes if isinstance(r, Route)],
            "mode": "autoprobe",
            "upstreamPostPath": STATE.post_path,
            "upstreamPostMode": STATE.post_mode,
            "upstreamPathCandidates": POST_PATH_TEMPLATES,
            "probeTimeout": PROBE_TIMEOUT,
        }
    )


@app.get("/debug/upstream")
async def debug_upstream():
    await ensure_config()
    return JSONResponse(STATE.to_dict())


@app.get("/debug/routes")
async def debug_routes():
    routes = []
    for r in app.router.routes:
        if isinstance(r, Route):
            routes.append(f"{r.path} ({','.join(r.methods)})")
    return JSONResponse({"routes": routes})


@app.get("/debug/scan")
async def debug_scan():
    await ensure_config()
    return JSONResponse(
        {
            "results": STATE.probe_results,
            "chosen": {"postPath": STATE.post_path, "postMode": STATE.post_mode},
        }
    )


@app.get("/mcp")
async def mcp_sse(request: Request):
    """
    Proxy SSE from upstream /{server}/sse.
    """
    await ensure_config()
    if not STATE.sse_path:
        return PlainTextResponse("SSE upstream not configured", status_code=503)

    upstream_url = f"{UPSTREAM_BASE}{STATE.sse_path}"

    async def event_stream():
        try:
            async with HTTP.stream(
                "GET", upstream_url, headers={"Accept": "text/event-stream"}
            ) as r:
                # propagate upstream status errors
                if r.status_code >= 400:
                    yield f"event: error\ndata: upstream status {r.status_code}\n\n".encode(
                        "utf-8"
                    )
                    return
                async for chunk in r.aiter_raw():
                    # passthrough raw SSE bytes
                    yield chunk
        except asyncio.CancelledError:
            return
        except Exception as e:
            yield f": keep-alive\n\nevent: error\ndata: {str(e)}\n\n".encode("utf-8")

    return StreamingResponse(
        event_stream(),
        media_type="text/event-stream",
        headers={"Cache-Control": "no-cache"},
    )


@app.post("/mcp")
async def mcp_post(request: Request):
    """
    Accept JSON-RPC and forward using discovered upstream path & envelope.
    """
    await ensure_config()
    if not (STATE.post_path and STATE.post_mode):
        # last-ditch: try probing again once
        STATE.post_path = None
        STATE.post_mode = None
        STATE.probe_results = []
        if STATE.default_server:
            post_path, post_mode, results = await probe_post_endpoint(
                STATE.default_server
            )
            STATE.post_path, STATE.post_mode, STATE.probe_results = (
                post_path,
                post_mode,
                results,
            )

    if not (STATE.post_path and STATE.post_mode):
        return PlainTextResponse("Upstream POST endpoint not found", status_code=502)

    body = await request.body()
    headers, out_body = _wrap_body(STATE.post_mode, body)

    # Forward
    upstream_url = f"{UPSTREAM_BASE}{STATE.post_path}"
    try:
        r = await HTTP.post(upstream_url, content=out_body, headers=headers)
        # Normalize: always reply with the upstream body/status, but never forward 301/302 (return 200+body)
        sc = r.status_code
        if 300 <= sc < 400:
            # don't leak redirects to client
            return Response(
                content=r.content,
                media_type=r.headers.get("content-type", "application/json"),
                status_code=200,
                headers={
                    "x-bridge-upstream-path": STATE.post_path,
                    "x-bridge-upstream-status": str(sc),
                    "x-bridge-upstream-url": upstream_url,
                },
            )
        return Response(
            content=r.content,
            media_type=r.headers.get("content-type", "application/json"),
            status_code=sc,
            headers={
                "x-bridge-upstream-path": STATE.post_path,
                "x-bridge-upstream-status": str(sc),
                "x-bridge-upstream-url": upstream_url,
            },
        )
    except Exception as e:
        return PlainTextResponse(f"Bridge upstream error: {e}", status_code=502)


# Root fallback (optional)
@app.api_route(
    "/{full_path:path}",
    methods=["GET", "POST", "HEAD", "OPTIONS", "PUT", "PATCH", "DELETE"],
)
async def reverse_proxy_catchall(full_path: str, request: Request):
    # Provide a friendly 404 from the bridge; don't expose upstream 404s by default.
    return PlainTextResponse("404 page not found\n", status_code=404)


# Startup: warm the config
@app.on_event("startup")
async def startup_event():
    try:
        await ensure_config()
    except Exception:
        # don't crash on startup; endpoints can still trigger ensure_config()
        pass


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "stream_http_bridge:app",
        host="0.0.0.0",
        port=9090,
        reload=False,
        log_level="info",
    )
