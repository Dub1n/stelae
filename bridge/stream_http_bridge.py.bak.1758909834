#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Stelae MCP Bridge - HTTP+SSE auto-probing bridge for ChatGPT Connector compliance.

Public surface:
  GET  /mcp            -> proxy SSE to upstream /{server}/sse
  POST /mcp            -> forward to discovered /{server}/message (or similar),
                          trying several envelopes until the upstream accepts
  GET  /healthz
  GET  /version
  GET  /debug/upstream
  GET  /debug/routes
  GET  /debug/scan

Upstream (local proxy) is assumed at http://127.0.0.1:9092
Manifest at /.well-known/mcp/manifest.json defines SSE URLs like .../{name}/sse

POST discovery tries these path templates:
  /{name}, /{name}/, /{name}/message, /{name}/messages, /{name}/rpc, /{name}/jsonrpc, /{name}/send

Key improvement:
- Treat HTTP 400 from a path as a *valid* signal that the handler exists but
  disliked our probe payload. We mark it as "adaptive" and, on real requests,
  try multiple envelopes in sequence to maximize acceptance.
"""

import asyncio
import json
import os
from typing import Any, Dict, List, Optional, Tuple

import httpx
from fastapi import FastAPI, Request, Response
from fastapi.responses import JSONResponse, PlainTextResponse, StreamingResponse
from starlette.middleware.cors import CORSMiddleware
from starlette.routing import Route

# ----------------------------
# Configuration
# ----------------------------

BRIDGE_VERSION = os.environ.get("BRIDGE_VERSION", "stelae-bridge/0.4.1-adaptive")
PUBLIC_BASE = os.environ.get("PUBLIC_BASE_URL", "https://mcp.infotopology.xyz")
UPSTREAM_BASE = os.environ.get("UPSTREAM_BASE_URL", "http://127.0.0.1:9092")
MANIFEST_PATH = "/.well-known/mcp/manifest.json"
PROBE_TIMEOUT = float(os.environ.get("PROBE_TIMEOUT", "2.5"))
DEFAULT_PROTOCOL_HINT = "2024-11-05"
PREFERRED_SERVER = os.environ.get("PREFERRED_SERVER", "mem")

POST_PATH_TEMPLATES = [
    "/{name}",
    "/{name}/",
    "/{name}/message",
    "/{name}/messages",
    "/{name}/rpc",
    "/{name}/jsonrpc",
    "/{name}/send",
]


# Envelope builder
def build_envelopes(payload: Dict[str, Any]) -> List[Tuple[str, Dict[str, str], bytes]]:
    raw = json.dumps(payload).encode("utf-8")
    return [
        ("json", {"Content-Type": "application/json"}, raw),
        (
            "wrapped",
            {"Content-Type": "application/json"},
            json.dumps({"message": payload}).encode("utf-8"),
        ),
        (
            "type_wrapped",
            {"Content-Type": "application/json"},
            json.dumps({"type": "message", "data": payload}).encode("utf-8"),
        ),
        ("ndjson", {"Content-Type": "application/x-ndjson"}, raw + b"\n"),
        ("text", {"Content-Type": "text/plain"}, raw),
        (
            "form",
            {"Content-Type": "application/x-www-form-urlencoded"},
            b"data=" + httpx.QueryParams({"data": raw.decode()}).encode(),
        ),
    ]


# A safe probe RPC (idempotent)
PROBE_RPC = {
    "jsonrpc": "2.0",
    "id": "probe",
    "method": "initialize",
    "params": {"protocolVersion": DEFAULT_PROTOCOL_HINT},
}

# ----------------------------
# App state
# ----------------------------

app = FastAPI(title="Stelae MCP Bridge", version=BRIDGE_VERSION)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_headers=["*"],
    allow_methods=["*"],
)


class UpstreamConfig:
    def __init__(self) -> None:
        self.server_names: List[str] = []
        self.default_server: Optional[str] = None
        self.sse_path: Optional[str] = None
        self.post_path: Optional[str] = None
        self.post_mode: Optional[str] = None  # "json"/"wrapped"/... or "adaptive"
        self.probe_results: List[Dict[str, Any]] = []
        self.manifest_ok: bool = False

    def to_dict(self) -> Dict[str, Any]:
        return {
            "base": UPSTREAM_BASE,
            "manifest": f"{UPSTREAM_BASE}{MANIFEST_PATH}",
            "serverNames": self.server_names,
            "defaultServer": self.default_server,
            "ssePath": self.sse_path,
            "postPath": self.post_path,
            "postMode": self.post_mode,
            "manifestOk": self.manifest_ok,
            "probeResults": self.probe_results,
        }


STATE = UpstreamConfig()
HTTP = httpx.AsyncClient(
    timeout=PROBE_TIMEOUT, follow_redirects=True, headers={"X-Bridge": "stelae"}
)

# ----------------------------
# Discovery / probing
# ----------------------------


async def fetch_manifest() -> Dict[str, Any]:
    r = await HTTP.get(f"{UPSTREAM_BASE}{MANIFEST_PATH}")
    r.raise_for_status()
    return r.json()


async def discover_servers() -> List[str]:
    try:
        m = await fetch_manifest()
        STATE.manifest_ok = True
    except Exception:
        STATE.manifest_ok = False
        return []
    names: List[str] = []
    for s in m.get("servers", []):
        u = s.get("url")
        if not isinstance(u, str):
            continue
        parts = u.strip("/").split("/")
        if parts and parts[-1] == "sse" and len(parts) >= 2:
            names.append(parts[-2])
    return sorted(set(names))


def choose_default_server(names: List[str]) -> Optional[str]:
    if not names:
        return None
    return PREFERRED_SERVER if PREFERRED_SERVER in names else names[0]


async def probe_post_endpoint(
    server: str,
) -> Tuple[Optional[str], Optional[str], List[Dict[str, Any]]]:
    """
    Try path templates and envelope modes.
    Success if status in {200..204}; otherwise remember *first* path that returns 400
    and mark it as "adaptive" (handler exists but wants a different envelope).
    """
    results: List[Dict[str, Any]] = []
    payload = PROBE_RPC
    envelopes = build_envelopes(payload)
    success = {200, 201, 202, 204}
    first_400: Optional[str] = None

    for tpl in POST_PATH_TEMPLATES:
        path = tpl.format(name=server)
        url = f"{UPSTREAM_BASE}{path}"
        for mode, headers, body in envelopes:
            try:
                r = await HTTP.post(url, content=body, headers=headers)
                results.append({"path": path, "mode": mode, "status": r.status_code})
                if r.status_code in success:
                    return path, mode, results
                if r.status_code == 400 and first_400 is None:
                    first_400 = path
            except Exception as e:
                results.append({"path": path, "mode": mode, "error": str(e)})
                continue

    if first_400:
        return first_400, "adaptive", results
    return None, None, results


async def ensure_config() -> None:
    if STATE.default_server and STATE.sse_path and STATE.post_path and STATE.post_mode:
        return
    names = await discover_servers()
    STATE.server_names = names
    STATE.default_server = choose_default_server(names)
    if STATE.default_server:
        STATE.sse_path = f"/{STATE.default_server}/sse"
        post_path, post_mode, results = await probe_post_endpoint(STATE.default_server)
        STATE.post_path, STATE.post_mode, STATE.probe_results = (
            post_path,
            post_mode,
            results,
        )
    else:
        STATE.sse_path = None
        STATE.post_path = None
        STATE.post_mode = None
        STATE.probe_results = []


def _wrap_body(mode: str, data: bytes) -> Tuple[Dict[str, str], bytes]:
    # Convert inbound JSON into a chosen envelope
    try:
        payload = json.loads(data.decode("utf-8"))
    except Exception:
        return {"Content-Type": "text/plain"}, data
    for m, headers, body in build_envelopes(payload):
        if m == mode:
            return headers, body
    return {"Content-Type": "application/json"}, json.dumps(payload).encode("utf-8")


# ----------------------------
# Routes
# ----------------------------


@app.get("/healthz")
async def healthz():
    try:
        await ensure_config()
        reachable = False
        sc = None
        if STATE.post_path:
            try:
                r = await HTTP.get(f"{UPSTREAM_BASE}{STATE.post_path}")
                sc = r.status_code
                reachable = True
            except Exception:
                reachable = False
        return JSONResponse(
            {
                "status": "ok",
                "bridge": BRIDGE_VERSION,
                "elapsed_ms": 0,
                "upstream": {
                    "base": UPSTREAM_BASE,
                    "manifest": f"{UPSTREAM_BASE}{MANIFEST_PATH}",
                    "postPath": STATE.post_path,
                    "postMode": STATE.post_mode,
                    "reachable": reachable,
                    "status": sc,
                },
                "server": STATE.default_server,
            }
        )
    except Exception as e:
        return JSONResponse({"status": "error", "error": str(e)}, status_code=500)


@app.get("/version")
async def version():
    await ensure_config()
    return JSONResponse(
        {
            "bridge": BRIDGE_VERSION,
            "python": "{}.{}.{}".format(*tuple(__import__("sys").version_info[:3])),
            "upstreamBaseURL": UPSTREAM_BASE,
            "publicBaseURL": PUBLIC_BASE,
            "protocolHint": DEFAULT_PROTOCOL_HINT,
            "routes": [r.path for r in app.router.routes if isinstance(r, Route)],
            "mode": "autoprobe+adaptive",
            "upstreamPostPath": STATE.post_path,
            "upstreamPostMode": STATE.post_mode,
            "upstreamPathCandidates": POST_PATH_TEMPLATES,
            "probeTimeout": PROBE_TIMEOUT,
        }
    )


@app.get("/debug/upstream")
async def debug_upstream():
    await ensure_config()
    return JSONResponse(STATE.to_dict())


@app.get("/debug/routes")
async def debug_routes():
    routes = []
    for r in app.router.routes:
        if isinstance(r, Route):
            routes.append(f"{r.path} ({','.join(r.methods)})")
    return JSONResponse({"routes": routes})


@app.get("/debug/scan")
async def debug_scan():
    await ensure_config()
    return JSONResponse(
        {
            "results": STATE.probe_results,
            "chosen": {"postPath": STATE.post_path, "postMode": STATE.post_mode},
        }
    )


@app.get("/mcp")
async def mcp_sse(request: Request):
    await ensure_config()
    if not STATE.sse_path:
        return PlainTextResponse("SSE upstream not configured", status_code=503)
    upstream_url = f"{UPSTREAM_BASE}{STATE.sse_path}"

    async def event_stream():
        try:
            async with HTTP.stream(
                "GET", upstream_url, headers={"Accept": "text/event-stream"}
            ) as r:
                if r.status_code >= 400:
                    yield f"event: error\ndata: upstream status {r.status_code}\n\n".encode()
                    return
                async for chunk in r.aiter_raw():
                    yield chunk
        except asyncio.CancelledError:
            return
        except Exception as e:
            yield f": keep-alive\n\nevent: error\ndata: {str(e)}\n\n".encode()

    return StreamingResponse(
        event_stream(),
        media_type="text/event-stream",
        headers={"Cache-Control": "no-cache"},
    )


@app.post("/mcp")
async def mcp_post(request: Request):
    await ensure_config()
    if not (STATE.post_path and STATE.post_mode):
        # one more attempt
        if STATE.default_server:
            post_path, post_mode, results = await probe_post_endpoint(
                STATE.default_server
            )
            STATE.post_path, STATE.post_mode, STATE.probe_results = (
                post_path,
                post_mode,
                results,
            )
    if not (STATE.post_path and STATE.post_mode):
        return PlainTextResponse("Upstream POST endpoint not found", status_code=502)

    upstream_url = f"{UPSTREAM_BASE}{STATE.post_path}"
    body = await request.body()

    # If we know an exact mode, try it; if "adaptive", try a sequence.
    if STATE.post_mode != "adaptive":
        headers, out_body = _wrap_body(STATE.post_mode, body)
        try:
            r = await HTTP.post(upstream_url, content=out_body, headers=headers)
            return Response(
                content=r.content,
                media_type=r.headers.get("content-type", "application/json"),
                status_code=r.status_code,
                headers={
                    "x-bridge-upstream-path": STATE.post_path,
                    "x-bridge-upstream-status": str(r.status_code),
                    "x-bridge-upstream-url": upstream_url,
                },
            )
        except Exception as e:
            return PlainTextResponse(f"Bridge upstream error: {e}", status_code=502)

    # Adaptive mode: try multiple envelopes until upstream does not answer 400/404/405/415/422
    # Order is chosen to minimize side-effects.
    rejection = {400, 404, 405, 415, 422}
    last_resp: Optional[httpx.Response] = None
    last_err: Optional[str] = None

    # Attempt sequence (json -> wrapped -> type_wrapped -> ndjson -> text -> form)
    try:
        payload = json.loads(body.decode("utf-8"))
    except Exception:
        payload = body  # non-JSON passthrough

    for mode, headers, out_body in build_envelopes(
        payload
        if isinstance(payload, dict)
        else {"message": body.decode("utf-8", "ignore")}
    ):
        try:
            r = await HTTP.post(upstream_url, content=out_body, headers=headers)
            last_resp = r
            if r.status_code not in rejection:
                return Response(
                    content=r.content,
                    media_type=r.headers.get("content-type", "application/json"),
                    status_code=r.status_code,
                    headers={
                        "x-bridge-upstream-path": STATE.post_path,
                        "x-bridge-upstream-status": str(r.status_code),
                        "x-bridge-upstream-url": upstream_url,
                        "x-bridge-tried-mode": mode,
                    },
                )
        except Exception as e:
            last_err = str(e)
            continue

    # If we reached here, return best-known info
    if last_resp is not None:
        return Response(
            content=last_resp.content,
            media_type=last_resp.headers.get("content-type", "text/plain"),
            status_code=last_resp.status_code,
            headers={
                "x-bridge-upstream-path": STATE.post_path,
                "x-bridge-upstream-status": str(last_resp.status_code),
                "x-bridge-upstream-url": upstream_url,
                "x-bridge-tried": "adaptive",
            },
        )
    if last_err:
        return PlainTextResponse(f"Bridge upstream error: {last_err}", status_code=502)
    return PlainTextResponse("Upstream POST rejected all envelopes", status_code=502)


@app.api_route(
    "/{full_path:path}",
    methods=["GET", "POST", "HEAD", "OPTIONS", "PUT", "PATCH", "DELETE"],
)
async def reverse_proxy_catchall(full_path: str, request: Request):
    return PlainTextResponse("404 page not found\n", status_code=404)


@app.on_event("startup")
async def startup_event():
    try:
        await ensure_config()
    except Exception:
        pass


if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        "stream_http_bridge:app",
        host="0.0.0.0",
        port=9090,
        reload=False,
        log_level="info",
    )
