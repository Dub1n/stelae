--- bridge/stream_http_bridge.py
+++ bridge/stream_http_bridge.py
@@
 async def post_mcp(request: Request) -> Response:
@@
-    async with httpx.AsyncClient(timeout=httpx.Timeout(30, read=30)) as client:
-        try:
-            r = await client.post(endpoint, json=payload)
-        except Exception as e:
+    async with httpx.AsyncClient(timeout=httpx.Timeout(30, read=30)) as client:
+        try:
+            r = await client.post(
+                endpoint,
+                json=payload,
+                headers={"Accept": "application/json"},
+            )
+        except Exception as e:
             return JSONResponse(
                 {"error": f"upstream post failed: {e}"},
                 status_code=502,
                 headers=resp_headers,
             )
 
-    # Proxy back error bodies to help debugging; otherwise accept
-    if r.status_code >= 400:
+    # quick failover on 404/405 -> try other path candidates once
+    if r.status_code in (404, 405):
+        for alt in [p for p in PATH_CANDIDATES if p != UPSTREAM_POST_PATH]:
+            alt_url = urljoin(UPSTREAM_BASE, alt.lstrip("/"))
+            try:
+                r2 = await client.post(
+                    alt_url, json=payload, headers={"Accept": "application/json"}
+                )
+                if r2.status_code < 400:
+                    # promote the working path for this process
+                    resp_headers["X-Bridge-Upstream-Path"] = alt
+                    resp_headers["X-Bridge-Upstream-URL"] = alt_url
+                    # update globals so next calls go straight there
+                    global UPSTREAM_POST_PATH, UPSTREAM_POST_URL
+                    UPSTREAM_POST_PATH, UPSTREAM_POST_URL = alt, alt_url
+                    SESSION_ENDPOINTS.clear()
+                    r = r2
+                    break
+            except Exception:
+                pass
+
+    # on error: return upstream status + body so callers can see details
+    if r.status_code >= 400:
         resp_headers["X-Bridge-Upstream-Status"] = str(r.status_code)
-        return JSONResponse(
-            {"upstream": r.status_code, "body": r.text},
-            status_code=502,
-            headers=resp_headers,
-        )
-
-    resp_headers["X-Bridge-Upstream-Status"] = str(r.status_code)
-    # Success: the bridge typically doesn't need to return the upstream JSON-RPC body.
-    # If you want to pass-through bodies, change this to return r.content with r.status_code.
-    return Response(status_code=202, headers=resp_headers)
+        return Response(
+            content=r.content,
+            status_code=502,
+            headers={**resp_headers, "Content-Type": r.headers.get("content-type", "application/json")},
+        )
+    # success: pass upstream body and status through
+    resp_headers["X-Bridge-Upstream-Status"] = str(r.status_code)
+    return Response(
+        content=r.content,
+        status_code=r.status_code,
+        headers={**resp_headers, "Content-Type": r.headers.get("content-type", "application/json")},
+    )
@@
 async def debug_upstream(_: Request) -> Response:
@@
     return JSONResponse(info, status_code=200)
 
+async def debug_routes(_: Request) -> Response:
+    try:
+        async with httpx.AsyncClient(timeout=httpx.Timeout(2, read=2)) as client:
+            r = await client.get(urljoin(UPSTREAM_BASE, "/openapi.json"))
+        return Response(
+            content=r.content,
+            status_code=r.status_code,
+            media_type=r.headers.get("content-type", "application/json"),
+        )
+    except Exception as e:
+        return JSONResponse({"error": f"route probe failed: {e}"}, status_code=502)
@@
 routes = [
@@
     Route("/debug/upstream", debug_upstream, methods=["GET"]),
+    Route("/debug/routes", debug_routes, methods=["GET"]),
@@
 ]
